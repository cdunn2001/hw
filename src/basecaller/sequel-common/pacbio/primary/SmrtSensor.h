#ifndef Sequel_Common_SmrtSensor_H_
#define Sequel_Common_SmrtSensor_H_

// Copyright (c) 2016, Pacific Biosciences of California, Inc.
//
// All rights reserved.
//
// THIS SOFTWARE CONSTITUTES AND EMBODIES PACIFIC BIOSCIENCES' CONFIDENTIAL
// AND PROPRIETARY INFORMATION.
//
// Disclosure, redistribution and use of this software is subject to the
// terms and conditions of the applicable written agreement(s) between you
// and Pacific Biosciences, where "you" refers to you or your company or
// organization, as applicable.  Any other disclosure, redistribution or
// use is prohibited.
//
// THIS SOFTWARE IS PROVIDED BY PACIFIC BIOSCIENCES AND ITS CONTRIBUTORS "AS
// IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
// PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL PACIFIC BIOSCIENCES OR ITS
// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
// OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
// WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
// OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
// ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
//
//  Description:
//  Defines struct SmrtSensor.

#include <array>
#include <iterator>

#include <pacbio/PBException.h>
#include <pacbio/primary/Util.h>
#include <pacbio/text/String.h>
//#include "SequelMovie.h"
//#include <pacbio/primary/Kernel.h>

#include <boost/multi_array.hpp>
#include <boost/numeric/conversion/cast.hpp>

namespace PacBio {
namespace Primary {

/// A simple concrete struct that bundles key characteristics of the sensor
/// and acquisition process.
/// All spectral elements are ordered by wavelength.
class SmrtSensor
{
public:     // Types

    /// N-dimensional array of elements of type T.
    template <typename T, size_t N>
    using MultiArray = boost::multi_array<T, N>;

public:
    /// Number of filter channels.
    uint32_t NumFilters() const { return numFilters_; }

public:     // Structors
    SmrtSensor(uint32_t numFilter);

    SmrtSensor(const SmrtSensor&) = default;

    // TODO: When multi_array provides move operations, we should add move ops to SmrtSensor.
    // As of 2016-02-03, multi_array does not support move operations.

public:     // Assignment
    SmrtSensor& operator=(const SmrtSensor&) = default;

    SmrtSensor* Clone() const
    {
        return new SmrtSensor(*this);
    }

public:     // Const member access
    /// Pixel data index.
    /// For example, filterMap[0] is the index for the green pixel.
    const std::vector<uint16_t>& FilterMap() const
    { return filterMap_; }

    template<int NCam>
    const std::array<uint16_t,NCam> FilterMapArray() const
    {
        // SpiderOnSequel may have two entries in filterMap_ with 1 being the
        // first one, but will call this function with NCam=1, which eventually
        // causes array out-of-bounds accesses.
        // So when NCam==1, just return {0} instead.

        // Initialize the array to be returned with zero(es).
        std::array<uint16_t,NCam> a {};
        if (NCam > 1)
        {
            assert(a.size() == filterMap_.size());
            std::copy(filterMap_.cbegin(), filterMap_.cend(), a.begin());
        }
        return a;
    }

#if 0
    /// The image PSFs of the spatial crosstalk.
    /// First index selects filter channel.
    /// Second and third indices select pixel offset of PSF coefficient.
    /// For Sequel PA 3.x, size will typically be (2, 5, 5).
    const MultiArray<float, 3>& ImagePsf() const
    { return imagePsf; }

    /// The filter applied to the trace data to correct for crosstalk.
    /// Same filter used all filter channels.
    /// For Sequel PA 3.x, size will typically be (7, 7).
    const MultiArray<float, 2>& XtalkCorrection() const
    { return xtalkCorrection; }
#endif

    /// SNR of reference analog in dye-weighted-sum terms.
    float RefDwsSnr() const
    { return refDwsSnr; }

    /// Spectrum of reference analog.
    const std::vector<float>& RefSpectrum() const
    { return refSpectrum; }

    template<int NCam>
    const std::array<float,NCam> RefSpectrumArray() const
    {
        std::array<float, NCam> a;
        std::copy(refSpectrum.cbegin(), refSpectrum.cend(), a.begin());
        return a;
    }

    /// (pe-/count)
    double PhotoelectronSensitivity() const
    { return photoelectronSensitivity_; }

    /// Number of frames generated by sensor per second.
    float FrameRate() const
    { return frameRate_; }

public:     // Const functions
    std::vector<float> ShotNoiseCovar(uint32_t filterChannel);

public:     // Modifiers
    /// Sets FilterMap to given value.
    /// \returns *this.
    SmrtSensor& FilterMap(const std::vector<uint16_t>& value);

    /// Set FilterMap to a range, which must define a permutation of [0, NumFilters).
    /// \returns *this.
    template <typename InputIt>
    SmrtSensor& FilterMap(InputIt start, InputIt stop)
    {
        using SrcType = typename std::iterator_traits<InputIt>::value_type;
        using TargetType = uint16_t;
        if (std::distance(start, stop) != NumFilters())
        {
            throw PBException("filterMap must be " + std::to_string(NumFilters()) + " elements long, was " +
                              PacBio::Text::String::AsArray(start,stop));
        }
        using TargetType = uint16_t;
        std::vector<TargetType> fm(NumFilters());
        std::transform(start, stop, fm.begin(), boost::numeric_cast<TargetType, SrcType>);
        return FilterMap(fm);
    }

#if 0
    SmrtSensor& ImagePsf(const MultiArray<float, 3>& value);

    SmrtSensor& XtalkCorrection(const MultiArray<float, 2>& value);
#endif

    /// Sets RefDwsSnr to given value, which must be positive.
    /// \returns *this.
    SmrtSensor& RefDwsSnr(float value);

    /// Sets RefSpectrum to given value.
    /// Elements must be non-negative and must sum to 1.0f.
    SmrtSensor& RefSpectrum(const std::vector<float>& value);

    /// Sets RefSpectrum to a range.
    template <typename InputIt>
    SmrtSensor& RefSpectrum(InputIt start, InputIt stop)
    {
        using SrcType = typename std::iterator_traits<InputIt>::value_type;
        using TargetType = float;
        if (std::distance(start, stop) != NumFilters())
        {
            throw PBException("refSpectrum must be " + std::to_string(NumFilters()) + " elements long, was " +
                                      PacBio::Text::String::AsArray(start,stop));
        }
        std::vector<TargetType> rs(NumFilters());
        std::transform(start, stop, rs.begin(), boost::numeric_cast<TargetType, SrcType>);

        return RefSpectrum(rs);
    }

    /// Sets the photoelectron sensitivity (pe-/count)
    SmrtSensor& PhotoelectronSensitivity(double value)
    {
        photoelectronSensitivity_  = value;
        return *this;
    }

    /// Sets the frame rate (frames per second).
    SmrtSensor& FrameRate(float value)
    {
        frameRate_ = value;
        return *this;
    }
private:
    void SetNumFilters(uint32_t numFilters);

private:    // Data
    uint32_t numFilters_;

    std::vector<uint16_t> filterMap_;

    MultiArray<float, 3> imagePsf;

    MultiArray<float, 2> xtalkCorrection;

    float refDwsSnr;

    std::vector<float > refSpectrum;

//    void CalculateShotNoiseCovar(const MultidimensionVector<float>& imagePsf, const MultidimensionVector<float>& xtalkCorrection);
//    void CalculateShotNoiseCovar(const std::vector<Kernel>& imagePsfs, const Kernel& xtalkCorrection);

    // "photoelectronSensitivity". The inverse of "gain". The units are
    // photoelectrons per ADC count from the sensor.
    double photoelectronSensitivity_;

    float frameRate_;   // frames per second
};

}}  // PacBio::Primary

#endif // Sequel_Common_SmrtSensor_H_

