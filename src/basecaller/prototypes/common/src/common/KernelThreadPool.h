#ifndef KERNEL_THREAD_POOL_H
#define KERNEL_THREAD_POOL_H

#include "ZmwDataManager.h"

#include <pacbio/PBException.h>

#include <cstddef>
#include <thread>
#include <atomic>

namespace PacBio {
namespace Cuda {

// Light RAII wrapper around an std::thread
// TODO consider removing the thread id functionality.  Currently unused.
struct ThreadRunner
{
    template <typename Func, typename... Args>
    ThreadRunner(Func&& f, Args... args)
    {
        tid = ++instanceCount_;
        t = std::thread(std::forward<Func>(f), std::forward<Args>(args)...);
    }

    ThreadRunner(const ThreadRunner&) = delete;
    ThreadRunner(ThreadRunner&&) = default;
    ThreadRunner& operator=(const ThreadRunner&) = delete;
    ThreadRunner& operator=(ThreadRunner&&) = default;

    ~ThreadRunner()
    {
        if (t.joinable()) t.join();
    }
private:
    std::thread t;
    size_t tid;
    static std::atomic<size_t> instanceCount_;
};

// Manages a thead pool of workers to process data generated by a ZmwDataManager.
// Func is expected to be a functor with the signature:
//    (UnifiedCudaArray<short2>& input, size_t batchIdx, size_t blockIdx, UnifiedCudaArray<short2>& output){
template <typename Data_T, typename Func>
void RunThreads(
        size_t simulKernels,
        Data::ZmwDataManager<Data_T>& manager,
        const Func& f)
{
    auto func = [&manager, &f]() {
        while (manager.MoreData())
        {
            try {
                auto batch = manager.NextBatch();
                auto& input = batch.KernelInput();
                auto& output = batch.KernelOutput();
                f(input, batch.Batch(), output);
                manager.ReturnBatch(std::move(batch));
            } catch (std::runtime_error& e) {
                // Currently expected that we might throw if we learn there is no more data after
                // we've already tried to fetch the next batch.  That is benign, any other exception
                // implies a problem
                if (manager.MoreData())
                {
                    std::cerr << e.what() << std::endl;
                    throw PBException("Unexpected exception processing data");
                }
            }
        }
    };

    // Set up a threadpool to have them each asynchronously launch cuda kernels
    // to process the input data stream.  The destructor calls at the end of the
    // function will automatically wait and join the threads.
    std::vector<ThreadRunner> threads;
    threads.reserve(simulKernels);
    for(size_t i = 0; i < simulKernels; ++i)
    {
        threads.emplace_back(func);
    }
}


}}

#endif // KERNEL_THREAD_POOL_H
